#!/usr/bin/env python3
import os, sys, argparse
from ver_utils import *
from blessings import Terminal
bless_term = Terminal()


def print_green(s, **kw):
    print (bless_term.green(s), **kw)

def print_emph(s, **kw):
    print (bless_term.red(s), **kw)

def clone(url, name, subs, debug, branch="master", answer=None):
    if debug:
        print_green("clone(url=%s, name=%s, subs=%s, answer=%s)" % (url, name, subs, answer))
    out, err = git("clone --single-branch -b %s %s %s" % (branch, url, name), show=True, debug=debug)
    if out.find('fatal') == 0:
        print (out, file=sys.stderr)
        return

    if name:
        subdir = name
    else:
        if url[-1] == "/":
            subdir = url[:-1]
        else:
            subdir = url
        j = subdir.rfind("/")
        subdir = subdir[j+1:]

    os.chdir(subdir)
    f = open(".ver_root", "w")
    f.write("This represents the root ver project. Please only have one in the path!")
    f.close()

    path = os.path.abspath(".")
    for sub, commit, _ in get_subs():
        include = False
        if not subs:                            #if none specified, prompt for each
            if answer or answer==None and input("Include subproject %s?" % sub).lower()[:1] == 'y':
                include = True
        else:
            include = sub in subs
        if include:
            print ("including: ", sub)
            git("submodule init %s" % sub, show=debug, debug=debug)
            suburl, err = git("config --local submodule.data.url", show=debug, debug=debug)
            os.chdir(sub)
            # git("submodule update --init .", show=debug, debug=debug)
            # commit = git("rev-parse HEAD")[0]
            # git("checkout %s" % branch, show=debug, debug=debug)
            git("init", show=debug, debug=debug)
            git("remote add origin %s" % suburl.strip(), show=debug, debug=debug)
            git("pull origin %s" % branch, show=debug, debug=debug)
            git("reset --hard %s" % commit, show=debug, debug=debug)
            print("E", branch)
            update(branch, answer=False, debug=debug)
            if debug:
                print ("forcing %s branch %s to %s" % (sub, branch, commit))
        else:
            print ("ignoring:  ", sub)
        os.chdir(path)


def save(local=False, pull=None, debug=False, root=True):
    if pull:
        branch = pull
    else:
        branch = get_branch()
    print("SAVE", branch)
    if debug:
        print_green("save(local=%s, root=%s)" % (local, root))
    subs = get_subs(tracked_only=True)
    # print ("SUBS:", subs)
    for sub in subs:
        if debug:
            print ("Processing", sub[0])
        path = os.path.abspath(".")
        os.chdir(sub[0])
        save(local=local, pull=branch, debug=debug, root=False)
        os.chdir(path)
    if debug and root:
        print("Processing root project in", os.path.abspath("."))
    if not local:
        git("fetch origin %s" % branch, show=debug, debug=debug)
        git("merge --no-edit FETCH_HEAD", show=debug, debug=debug)

    git("add .", show=debug, debug=debug)

    out, good = git("status", show=debug, debug=debug)
    ret = ""
    for r in out.split("\n"):
        if r.find("\tmodified:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tdeleted:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tnew file:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\trenamed:") == 0:
            ret += r.strip() + "\n"

    out, err =git(["commit", "-m", ret], show=debug, debug=debug)
    if not local:
        out, err = git("push", show=debug, debug=debug)
    if root and not debug:
        print (out.split("\n")[-2])

def update(branch, answer=None, debug=False):
    if debug:
        print_green("update(branch=%s, answer=%s)" % (branch, answer))
    print ("F", branch)
    git("fetch origin %s" % branch, show=debug, debug=debug)  # could be slow -- prompt user?
    print ("G", branch)
    curbr = get_branch()
    print ("A", curbr)
    if branch and (curbr != branch):
        print("B", curbr)
        out, err = git("checkout %s" % branch, show=debug, debug=debug)
        if out.find("error: pathspec") == 0:                        # if branch does not exist,
            print("C", out)
            out, err = git("checkout --track origin/%s" % branch, show=debug, debug=debug)   # create it
            if out.find("fatal: ") == 0:                    # new remote
                if answer==None:
                    answer = input("branch %s does not exist, create?" % branch).lower()[:1] == 'y'
                    if answer==False:
                        return
                if answer:
                    print ("creating new branch: & tracking remote: %s" % branch)
                    git("checkout -b {0}".format(branch), show=debug, debug=debug)
                    git("push --set-upstream origin {0}".format(branch), show=debug, debug=debug)
                    git("push", show=debug, debug=debug)
    else:
        branch = curbr
    print ("D", branch)

    git("pull origin %s" % branch, show=debug, debug=debug)
    subs = get_subs(tracked_only=True)
    if subs:
        git("submodule update", show=debug, debug=debug)
        for sub in subs:
            if debug:
                print ("Processing", sub[0])
            path = os.path.abspath(".")
            os.chdir(sub[0])
            # os.system("pwd")
            update(branch, answer=True, debug=debug)
            os.chdir(path)


def merge(branch, debug=False):
    if debug:
        print_green("merge(branch=%s)" % (branch))
    if not branch:
        branch = 'master'
    oldbr = get_branch()
    save(local=False, debug=debug)
    git("pull origin %s" % branch, show=debug, debug=debug)
    update(branch=oldbr, debug=debug)
    git("checkout %s" % branch)
    git("pull origin %s" % oldbr, show=debug, debug=debug)
    update(branch=branch, debug=debug)
    if input("Delete branch %s?" % oldbr).lower()[:1] == 'y':
        git("push origin --delete %s" % oldbr, show=debug, debug=debug)
        git("branch -D %s" % branch, show=debug, debug=debug)


def pull(branch, debug=False):
    if debug:
        print_green("pull(branch=%s)" % (branch))
    if not branch:
        branch = 'master'
    oldbr = get_branch()
    save(local=False, debug=debug)
    git("pull origin %s" % branch, show=debug, debug=debug)
    update(branch=oldbr, debug=debug)


def status(debug=False):
    if debug:
        print_green("status()")
    out, good = git("branch", show=debug, debug=debug)
    for n in out.split("\n"):
        if n[:1] == '*':
            print ("On branch: %s" % n[2:])
    out, good = git("status", show=debug, debug=debug)
    ret = ""
    untracked = []
    for r in out.split("\n"):
        if r.find("\tmodified:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tdeleted:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tnew file:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\trenamed:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\t") == 0:
            untracked.append(r.strip())
    print(ret, end="")
    print("%d untracked item%s" % (len(untracked), "s:" if len(untracked) > 1 else ":" if len(untracked) == 1 else "s"),
          " ", ", ".join(untracked))

    print ("Submodules:")
    curbr = get_branch()
    subs = get_subs()
    sync = True
    for sub in subs:
        path = os.path.abspath(".")
        os.chdir(sub[0])
        subbr = get_branch()
        if subbr != curbr:
            sync = False
        print ("%s:  %s(%s) is on branch %s %s" % (sub[2], sub[0], sub[1][:6], subbr, "" if subbr==curbr else "UNSYNCED" ))
        os.chdir(path)
    if not sync:
        print ("WARNING: submodules out of sync")


def help():
    print_emph("clone <url> [--name] [--subs]")
    print ("like git clone\n")
    print_emph("save")
    print ("commit to local workspace\n")
    print_emph("sync")
    print ("sync with remote (pull + push)\n")
    print_emph("branch <branch>")
    print ("create or switch to a branch")
    print ("if no branch specified, show available\n")
    print_emph("pull <branch>")
    print ("merge from branch to ourbranch\n")
    print_emph("merge <branch>")
    print ("""merge both ways; if successful, delete old branch
default == master
in future, trigger merge request if newbranch is owned/protected
""")
    print_emph("sub <folder>")
    print ("create subproject\n")


def sub(remote, name=None, debug=False, answer=None):
    """
mkdir sub1
cd sub1
git init
git remote add origin $PWD/../../../_tests/sub1bare
echo "rooty/sub1" > rooty_file1
git add rooty_file1
git commit -am "rooty/rooty_file1 commit 1 (sub1)"
git push --set-upstream origin master

cd ../
git submodule add ~/ver/_tests/sub1bare sub1
git submodule update --init
git commit -am "rooty/rooty_file1 commit 1 (rooty)"
git push --set-upstream origin master
"""
    if not name:
        name = remote
        if name[-1] == "/":
            name = name[:-1]
        j = name.rfind("/")
        name = name[j + 1:]
    path = os.path.abspath(name)
    if answer or answer == None and input("Create submodule at %s tracking %s?" % (path, remote)).lower()[:1] == 'y':
        pass
    return
    os.mkdir(name)
    os.chdir(name)

# def new(remote, name=None, debug=False, answer=None):
#     if name[-1] == "/":
#         name = name[:-1]
#     j = name.rfind("/")
#     name = name[j + 1:]
#     path = os.path.abspath(name)
#     if answer or answer == None and input("Create submodule at %s tracking %s?" % (path, remote)).lower()[:1] == 'y':
#         pass
#     return
#     os.mkdir(name)
#     os.chdir(name)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('cmd')
    parser.add_argument('arg2', nargs='?')
    parser.add_argument('--name', default="")
    parser.add_argument('--branch', default="master")
    parser.add_argument('--subs', default="")
    parser.add_argument('--debug', action="store_true")
    parser.add_argument('--yes', action="store_true")
    parser.add_argument('--no', action="store_true")
    args = parser.parse_args()
    answer = True if args.yes else False if args.no else None    #None means prompt user
    print ("ver -- Versioning Easily Remembered")


    if args.cmd == 'help':
        help()

    elif args.cmd == 'clone':
        if is_ver_project():
            print("ERROR -- can't clone a new project within an existing one")
        else:
            clone(url=args.arg2, name=args.name, subs=args.subs, debug=args.debug, branch=args.branch, answer=answer)

    elif not is_ver_project():
        print("ERROR -- not a ver project")
        exit()

    else:
        chdir_root()

        if args.cmd == 'save':
            save(local=True, debug=args.debug)

        elif args.cmd == 'sync':
            save(local=False, debug=args.debug)

        elif args.cmd == 'merge':
            merge(branch=args.arg2, debug=args.debug)

        elif args.cmd == 'pull':
            if args.arg2:
                print ("PULL", args.arg2)
                save(local=False, pull=args.arg2, debug=args.debug)
            else:
                save(local=False, debug=args.debug)

        elif args.cmd == 'branch':
            if not args.arg2:
                print ("Here are all the branches:")
                out, err = git("branch", show=False, debug=args.debug)
                for b in out.split("\n"):
                    if b[:1] == '*':
                        print (b[2:], "<--YOU ARE HERE")
                    else:
                        print(b[2:])
            else:
                save(local=False, debug=args.debug)
                update(branch=args.arg2, debug=args.debug, answer=answer)

        elif args.cmd == 'status':
            status(args.debug)

        elif args.cmd == 'sub':
            sub(remote=args.arg2, name=args.name, answer=answer, debug=args.debug)


        else:
            print ("Unknown ver command: %s" % args.cmd)
