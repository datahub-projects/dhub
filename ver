#!/usr/bin/python3
import os, sys, argparse
from ver_utils import *


def clone(url, name, subs, debug, answer=None):
    print ("DBG-->%s<--" % subs)
    out, err = git("clone %s %s" % (url, name), show=True, debug=debug)
    if out.find('fatal') == 0:
        print (out, file=sys.stderr)
        return

    if name:
        branch = name
    else:
        if url[-1] == "/":
            branch = url[:-1]
        j = branch.rfind("/")
        branch = branch[j+1:]

    os.chdir(branch)
    f = open(".ver_root", "w")
    f.write("This represents the root ver project. Please only have one in the path!")
    f.close()

    path = os.path.abspath(".")
    for sub, commit in get_subs():
        include = False
        if not subs:                            #if none specified, prompt for each
            if answer or answer==None and input("Include subproject %s?" % sub).lower()[:1] == 'y':
                include = True
        else:
            include = sub in subs
        if include:
            print ("including: ", sub)
            os.chdir(sub)
            git("submodule update --init .", show=debug, debug=debug)
            commit = git("rev-parse HEAD")[0]
            git("checkout master", show=debug, debug=debug)
            update("master", answer=False, debug=debug)
            if debug:
                print ("forcing %s master branch to %s" % (sub, commit))
            git("reset --hard %s" % commit, show=debug, debug=debug)
        else:
            print ("ignoring:  ", sub)
        os.chdir(path)


def save(local=False, debug=False, root=True):
    subs = get_subs()
    for sub in subs:
        print ("Processing", sub[0])
        path = os.path.abspath(".")
        os.chdir(sub[0])
        save(local=local, debug=debug, root=False)
        os.chdir(path)
    if root:
        print("Processing root project in", os.path.abspath("."))
    if not local:
        git("fetch", show=debug, debug=debug)
        git("merge --no-edit FETCH_HEAD", show=True, debug=debug)
    git("add .", show=debug, debug=debug)
    git(["commit", "-m", '"ver commit"'], show=debug, debug=debug)
    if not local:
        git("push", show=True, debug=debug)


def update(branch, answer=None, debug=False):
    git("fetch", show=True, debug=debug)  # could be slow -- prompt user?
    curbr = get_branch()
    if branch and (curbr != branch):
        out, err = git("checkout %s" % branch, show=debug, debug=debug)
        if out.find("error: pathspec") == 0:                        # if branch does not exist,
            out, err = git("checkout --track origin/%s" % branch, show=debug, debug=debug)   # create it
            if out.find("fatal: ") == 0:                    # new remote
                if answer or answer==None and input("branch %s does not exist, create?" % branch).lower()[:1] == 'y':
                    print ("creating new branch: & tracking remote: %s" % branch)
                    git("checkout -b {0}".format(branch), show=True, debug=debug)
                    git("push --set-upstream origin {0}".format(branch), show=debug, debug=debug)
                    git("push", show=debug, debug=debug)
    else:
        branch = curbr

    git("pull", show=True, debug=debug)
    subs = get_subs()
    for sub in subs:
        print ("Processing", sub[0])
        path = os.path.abspath(".")
        os.chdir(sub[0])
        # os.system("pwd")
        update(branch, answer=False, debug=debug)
        os.chdir(path)
    if subs:
        git("submodule update", show=True, debug=debug)


def merge(branch, debug=False):
    if not branch:
        branch = 'master'
    oldbr = get_branch()
    save(local=False, debug=debug)
    git("pull origin %s" % branch, show=debug, debug=debug)
    update(branch=oldbr, debug=debug)
    git("checkout %s" % branch)
    git("pull origin %s" % oldbr, show=debug, debug=debug)
    update(branch=branch, debug=debug)
    if input("Delete branch %s?" % oldbr).lower()[:1] == 'y':
        git("push origin --delete %s" % oldbr, show=debug, debug=debug)
        git("branch -D %s" % branch, show=debug, debug=debug)


def pull(branch, debug=False):
    if not branch:
        branch = 'master'
    oldbr = get_branch()
    save(local=False, debug=debug)
    git("pull origin %s" % branch, show=debug, debug=debug)
    update(branch=oldbr, debug=debug)


def status(debug=False):
    out, good = git("branch", show=debug, debug=debug)
    for n in out.split("\n"):
        if n[:1] == '*':
            print ("On branch: %s" % n[2:])
    out, good = git("status", show=debug, debug=debug)
    ret = ""
    untracked = []
    for r in out.split("\n"):
        if r.find("\tmodified:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tdeleted:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\tnew file:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\trenamed:") == 0:
            ret += r.strip() + "\n"
        elif r.find("\t") == 0:
            untracked.append(r.strip())
    print(ret, end="")
    print("%d untracked item%s" % (len(untracked), "s:" if len(untracked) > 1 else ":" if len(untracked) == 1 else "s"),
          " ", ", ".join(untracked))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('cmd')
    parser.add_argument('arg2', nargs='?')
    parser.add_argument('--name', default="")
    parser.add_argument('--subs', default="")
    parser.add_argument('--debug', action="store_true")
    parser.add_argument('--yes', action="store_true")
    parser.add_argument('--no', action="store_true")
    args = parser.parse_args()
    answer = True if args.yes else False if args.no else None    #None means prompt user
    print ("ver -- Versioning Easily Remembered")

    if args.cmd == 'clone':
        if is_ver_project():
            print("ERROR -- can't clone a new project within an existing one")
        else:
            clone(url=args.arg2, name=args.name, subs=args.subs, debug=args.debug, answer=answer)

    elif not is_ver_project():
        print("ERROR -- not a ver project")
        exit()

    elif args.cmd == 'save':
        save(local=True, debug=args.debug)

    elif args.cmd == 'sync':
        save(local=False, debug=args.debug)

    elif args.cmd == 'merge':
        merge(branch=args.arg2, debug=args.debug)

    elif args.cmd == 'pull':
        save(local=False, debug=args.debug)

    elif args.cmd == 'branch':
        save(local=False, debug=args.debug)
        update(branch=args.arg2, debug=args.debug, answer=answer)

    elif args.cmd == 'status':
        status(args.debug)

    else:
        print ("Unknown ver command: %s" % args.cmd)
